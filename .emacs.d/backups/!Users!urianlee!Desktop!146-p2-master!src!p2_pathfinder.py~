
from math import sqrt
from heapq import heappush, heappop
import math


def find_path(source_point, destination_point, mesh):
    """
    Searches for a path from source_point to destination_point through the mesh

    Args:
        source_point: starting point of the pathfinder
        destination_point: the ultimate goal the pathfinder must reach
        mesh: pathway constraints the path adheres to

    Returns:
        A path (list of points) from source_point to destination_point if exists
        A list of boxes explored by the algorithm
    """

    path = []  # list that holds all boxes passed through
    boxes = {}  # dict that maps boxes to all adjacent / explored boxes
    box_w_entry = {}  # {((x1, x2, y1, y2), (x,y))} box, entry (x,y) pair
    box_w_entry_b = {}  # DUPLICATE
    queue = []  # heap that contains boxes to explore
    dist = {}  # dict that maps boxes to path cost
    dist_b = {}  # DUPLICATE
    prev = {}  # backpointing
    prev_b = {}  # DUPLICATE

    for first_box in mesh['boxes']:  # first_box not actually first box
        if is_in_box(source_point, first_box):  # function that checks if pt in box
            current_box = first_box  # Selects 1st Box
            source_box = first_box
            boxes[current_box] = None  # came_from[start] = None
            dist[current_box] = 0  # Sets distance of 1st Box
        if is_in_box(destination_point, first_box):
            dest_box = first_box
            dist_b[dest_box] = 0

    # This is where source_box is pushed to PQ
    heappush(queue, (0, current_box, 'destination'))
    # Also enqueue destination box - for Backwards Search
    heappush(queue, (0, dest_box, 'source'))
    current_point = source_point
    current_point_b = destination_point

    while len(queue) is not 0:
        smallest = math.inf
        #current_box = heappop(queue)[1]
        priority, current_box, current_goal = heappop(queue)
        boxes[current_box] = []
        for next_box in mesh['adj'][current_box]:
            adjacent = adj_edge(current_box, next_box)
            if current_goal == 'destination':
                temp_point = shortest_to_adj(
                    current_point, adjacent[0], adjacent[1])
                new_cost = dist[current_box] + \
                    distance(current_point, temp_point)
                if next_box not in dist or new_cost < dist[next_box]:
                    dist[next_box] = new_cost
                    prev[next_box] = current_box
                    box_w_entry[next_box] = temp_point
                    t_to_d = heuristic(temp_point, destination_point)
            elif current_goal == 'source':
                temp_point = shortest_to_adj(
                    current_point_b, adjacent[0], adjacent[1])
                new_cost = dist_b[current_box] + \
                    distance(current_point, temp_point)
                if next_box not in dist_b or new_cost < dist_b[next_box]:
                    dist_b[next_box] = new_cost
                    prev_b[next_box] = current_box
                    box_w_entry_b[next_box] = temp_point
                    t_to_d = heuristic(temp_point, source_point)
            priority = new_cost + t_to_d  # euc_dist from new to dest
            heappush(queue, (priority, next_box, current_goal))
            boxes[current_box].extend(next_box)
            # if is_in_box(destination_point, current_box):
        contact_box = crosspath_search(prev, prev_b)
        if contact_box is not None:
            break

    node = contact_box  # if current box terminates at destination_point
    node_b = contact_box
    path_pt = box_w_entry[node]
    path_pt_b = box_w_entry_b[node_b]
    while node is not contact_box or node_b is not contact_box:
        node_pt = box_w_entry[node]
        node_pt_b = box_w_entry_b[node_b]
        path.append((path_pt, node_pt))
        path.append((path_pt_b, node_pt_b))
        node = prev[node]
        node_b = prev_b[node_b]
        path_pt = node_pt
        path_pt_b = node_pt_b
    path.append((path_pt, source_point))
    path.append((path_pt_b, destination_point))
    return path, list(boxes.keys())


def adj_edge(b1, b2):
    '''
    Args:
        b1 = (x1, x2, y1, y2)
        b2 = (x1, x2, y1, y2)
    Return:
        edge = [ (x1, y1), (x2, y2) ]
    '''
    edge = None
    x_rng = [max(b1[0], b2[0]), min(b1[1], b2[1])]  # [x1, x2]
    y_rng = [max(b1[2], b2[2]), min(b1[3], b2[3])]  # [y1, y2]

    if y_rng[1] - y_rng[0] == 0:  # Above/Below
        if b1[3] == b2[2]:  # Box 1 is ABOVE Box 2
            edge = [(x_rng[0], b1[3]), (x_rng[1], b2[2])]
            return edge
        elif b1[2] == b2[3]:  # Box 1 is BELOW Box 2
            edge = [(x_rng[0], b1[2]), (x_rng[1], b2[3])]
            return edge
        else:  # Bad Cases
            return None
    elif x_rng[1] - x_rng[0] == 0:  # Left/Right
        if b1[0] == b2[1]:
            #        Then: Box 1 on Box 2's RIGHT !!!
            edge = [(b1[0], y_rng[0]), (b2[1], y_rng[1])]
            return edge
        elif b1[1] == b2[0]:
            #        Then: Box 1 on Box 2's LEFT !!!
            edge = [(b1[1], y_rng[0]), (b2[0], y_rng[1])]
            return edge
        else:  # Bad Cases
            return None
    else:  # Worst Corner Cases Ever
        return None


def shortest_to_adj(point, l1, l2):
    """
    Args:
        point: starting point
        l1: first endpoint of the edge
        l2: second endpoint of the edge

    Returns:
        A tuple that represents a point on the line that has the smallest
        euclidean distance between itself and the starting point
    """

    line = distance(l1, l2)
    if line == 0:
        return distance(point, l1)
    dot_product = ((point[0] - l1[0]) * (l2[0] - l1[0]) +
                   (point[1] - l1[1]) * (l2[1] - l1[1])) / line
    dp = max(0, min(1, dot_product))
    p1 = l1[0] + dp * (l2[0] - l1[0])
    p2 = l1[1] + dp * (l2[1] - l1[1])
    return (p1, p2)


def distance(p1, p2):
    """
    Args:
        p1: Starting point tuple
        p2: Destination point tuple

    Returns:
        Euclidean distance between p1 and p2
    """
    '''
    a = p1[0]
    b = p1[1]
    c = p2[0]
    d = p2[1]'''

    L = []
    for i, item in enumerate(p1):
        L.append(p1[i])
    for j, item in enumerate(p2):
        L.append(p2[i])
    a = float(L[0])
    b = float(L[1])
    c = float(L[2])
    d = float(L[3])
    # x = p2[0] - p1[0] # c - a
    # y = p2[1] - p1[1] # d - b
    return sqrt(((c - a)**2) + ((d - b)**2))


def is_in_box(pt, box):
    '''
    Args:
        pt = point (x,y)
        box = box (x1, x2, y1, y2)
    Returns:
        True: if point is inside box
        False: if point is not inside box
        '''
    if pt[0] >= box[0] and pt[0] <= box[1] and pt[1] >= box[2] and pt[1] <= box[3]:
        # since Y increases as you go down
        return True
    else:
        return False


def heuristic(a, b):
    (x1, y1) = a
    (x2, y2) = b
    return abs(x1 - x2) + abs(y1 - y2)


def crosspath_search(prev1, prev2):
    '''Args:
        prev1: dictionary {(box1, box2)}
        prev2: dictionary {(box1, box2)}

    Returns:
        The box in both prev lists
        '''
    for i in prev1:
        for j in prev2:
            if i[1] == j[1]:
                return i[1]
            else:
                return None
